'use strict';

var async = require('async'),
	_ = require('lodash');

var Model = function(data) {
	var self = this;
	self.model = {};
	self.data = {};
	var toCollection = function() {
		var output = [];
		self.model.model.forEach(function(item) {
			output.push({
				name: item.name,
				type: item.type,
				extend: item.extend,
				value: (item.name in self.data ? self.data[item.name] : null)
			});
		});
		return output;
	}
	self.load = function(data) {
		// TODO: coerce data to match the model, load defaults
		self.data = data;
	};
	self.define = function(model) {
		self.model = model;
	};
	self.safeToString = function(x) {
		switch (typeof x) {
			case 'object':
				return 'object';
			case 'function':
				return 'function';
			default:
				return x + '';
		}
	};
	self.validate = function(cb) {
		var validators = {},
			dataToValidate = [],
			result = {
				valid: true,
				messages: {}
			},
			validChecker = [],
			dataCollection = toCollection();

		function rangeValidater(start, end, prompt, cb) {
			var rangeResult = {};
			if (start < end) {
				rangeResult.valid = true;
				rangeResult.message = '';
			} else {
				rangeResult.valid = false;
				rangeResult.message = prompt;
			}
			return cb(null, rangeResult);
		}
		self.model.model.forEach(function(item) {
			if ('validation' in item && 'async' in item.validation) {
				validators[item.name] = item.validation.async;
			} else if ('validation' in item && 'range' in item.validation) {
				validators[item.name] = function(val, data, cb) {
					var start = data[item.validation.range.start],
						end = data[item.validation.range.end],
						prompt = data[item.validation.range.prompt]
					;
					rangeValidater(start, end, prompt, cb);
				};
			}
		});
		for (var key in self.data) {
			if (key in validators) {
				dataToValidate.push({
					name: key,
					data: self.data[key],
					validation: validators[key]
				});
			}
		}
		async.each(dataToValidate, function(item, callback) {
			item.validation(item.data, dataCollection, function(err, validationObject) {
				if (validChecker.indexOf(validationObject.valid) <= 0) {
					validChecker.push(validationObject.valid);
				}
				if (!validationObject.valid) {
					//result.messages.push(validationObject.message);
					result.messages[item.name] = validationObject.message;
				}
				return callback(err);
			})
		}, function(err, validationResult) {
			if (validChecker.indexOf(false) >= 0) {
				result.valid = false;
			}
			return cb(result);
		});
	};
	self.clientValidationRules = function() {
		var validators = {};
		self.model.model.forEach(function(item) {
			if ('validation' in item && 'rules' in item.validation) {
				validators[item.name] = {
					identifier: item.name,
					rules: item.validation.rules
				};
			}
		});
		return validators;
	}
};

module.exports = Model;
